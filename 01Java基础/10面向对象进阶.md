### 1.Static静态

![image-20241101193828550](https://gitee.com/ppedmo/pic-go/raw/master/img/202411011938628.png)

- Javabean类
  - 用来描述一类事物的类。比如，Student，Teacher，Dog，Cat等
  - 可用来创建对象
- 测试类
  - 用来检查其他类是否书写正确，带有main方法的类，**是程序的入口**
- 工具类：
  - 不是用来描述一类事物的，而是帮我们做一些事情的类
  - 直接通过类来调用
- 静态是和类相关的，优先于对象产生，而非静态则是和对象相关的。
- 静态方法没有this关键字，且只能访问静态变量，非静态方法可以访问所有
- 对于静态方法：==如果是作为一个工具来使用的，就声明为static，不需要new一个对象就可以使用==

### 2.继承

- 继承是面向对象三大特征之一，可以让类跟类之间产生子父的关系。

- 可以把多个子类中重复的代码抽取到父类中，子类可以直接使用，减少代码兄余，提高代码的复用性

- 关键字：==extends==

- 格式：`public class 子类 extends 父类 {}`

- 子类可以得到父类的属性和行为，子类可以使用。

- 子类可以在父类的基础上新增其他功能，子类更强大。

- 特点：只能单继承，不能多继承，但可以有多层继承

- java中所有的类都直接或间接继承于Object类

- 子类能继承父类的：

  ![image-20241101225235691](https://gitee.com/ppedmo/pic-go/raw/master/img/202411012252777.png)

  - 构造方法，不能继承要自己再定义

  - 成员变量：都能继承，只是私有的不能访问罢了----用get和set方法

  - 虚方法表

    ![image-20241101230851641](https://gitee.com/ppedmo/pic-go/raw/master/img/202411012308680.png)

    - object中有5个方法可以添加进去

- 继承中成员变量的访问特点：就近原则

  - 先在局部位置找，本类成员位置找，父类成员位置找，逐级往上，到父类就不能再上了

  - ```java
    System.out.println(name);
    System.out.println(this.name);
    System.out.println(super.name);
    ```

- 继承中方法的访问特点：就近原则

  - 方法的重写
    当父类的方法不能满足子类现在的需求时，需要进行方法重写

    重写会**覆盖**调父类--覆盖虚方法表中的方法

  - 书写格式
    在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。

  - @Override重写注解
    1.@Override是放在重写后的方法上，校验子类重写时语法是否正确。
    2.加上注解后如果有红色波浪线，表示语法错误
    建议重写方法都加@Override注解，
    3.代码安全，优雅!

- 方法重写注意事项：
  - 重写的方法尽量和父类保持一致
  - 只有被添加到虚方法表中的方法才能被重写（非private、非static、非final）

- 继承中构造方法的访问特点：

  - 子类不能继承父类的构造方法，但是可以通过super调用

  - 子类构造方法的第一行，有一个默认的super();

  - 默认先访问父类中无参的构造方法，再执行自己，

  - 如果想要方法文父类有参构造，必须手动书写

  - 总结：==先父类再子类，使用super()调用父类构造方法==

    ![image-20241103004859136](https://gitee.com/ppedmo/pic-go/raw/master/img/202411030048222.png)

- this和super用法总结：

  - this：相当于一个局部变量，记录当前对象的地址值，隐含的传入方法中

  - super：代表父类存储空间

    ![image-20241103010345099](https://gitee.com/ppedmo/pic-go/raw/master/img/202411030103154.png)

### 3.多态

- 什么是多态?
  - 对象的多种形态。
- 多态的前提?
  - 有继承/实现关系
  - 有父类引用指向子类对象
  - 有方法的重写
- 多态的好处?
  - 使用父类型作为参数，可以接收所有子类对象
  - 体现多态的扩展性与便利。

- ==小结==：使用父类类型变量接受子类变量，但能使用子类的方法（父类中有的，子类重写后的）

- 运行特点：

  - 调用成员变量时：编译看左边，运行看左边
  - 调用成员方法时：编译看左边，运行看右边

- 多态的优缺点

  ![image-20241103163306197](https://gitee.com/ppedmo/pic-go/raw/master/img/202411031633316.png)

### 4.包

- 什么是包 ?
  - 包就是文件夹。用来管理各种不同功能的Java类，方便后期代码维护
  - 包名的规则：公司域名反写+包的作用，需要全部英文小写，见名知意。com.itheima.domain
  - 真正访问类是要加上所在包的----com.itheima.domain.Student

- 导包：
  - 使用同一个包中的类时，不需要导包。
  - 使用java.lang包中的类时，不需要导包。
  - 其他情况都需要导包
  - 如果同时使用两个包中的同名类，需要用全类名----包名加类名

### 5.final

- final修饰的类，不能被继承。----没有子类了
- final修饰的方法，不能被重写。
- final修饰的变量，叫常量，只能赋值一次，不能再更改。
- 常量
  实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。
- 常量的命名规范:
  单个单词:全部大写
  多个单词:全部大写，单词之间用**下划线隔开**
- 细节:
  final修饰的变量是基本类型:那么变量存储的**数据值**不能发生改变，
  final修饰的变量是引用类型:那么变量存储的**地址值**不能发生改变，对象内部的可以改变

### 6.权限修饰符

![image-20241103184323611](https://gitee.com/ppedmo/pic-go/raw/master/img/202411031843732.png)

### 7.代码块

- 分类：局部，构造，静态代码块

- 静态代码块 ：随着类的加载而加载，并且只执行一次

  - ```java
    static{
    
    }
    ```

    

### 8.抽象类和抽象方法

- **abstract**关键字
- 抽象方法，没有方法体
- 抽象类
  - 抽象类可以没有抽象方法，有抽象方法一定是抽象类
  - 抽象类不能被实例化--无法创建对象
  - 抽象类有构造方法
- 抽象类的子类：要么重写全部抽象方法，要么也是一个抽象类

### 9.接口

- 接口是一种规则，对行为的抽象

- interface----接口

- impliements----实现，可以有多个实现

- 接口中成员的特点：

  - 成员变量，只能是常量，默认修饰符:public static final
  - 构造方法，没有
  - 成员方法，只能是抽象方法，默认修饰符:public abstract
  - DK7以前:接口中只能定义抽象方法。

- 接口和类之间的关系

  - 类和类的关系
    继承关系，只能单继承，不能多继承，但是可以多层继承

  - 类和接口的关系
    实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口

    多实现时若接口中有相同的方法，只取一个实现就可

  - 接口和接口的关系
    继承关系，可以单继承，也可以多继承

    如果实现了最下面的子接口，要重写所有的抽象方法

- 接口中的默认方法

  - 格式:public default 返回值类型 方法名(参数列表){ }

  - 注意事项:
    1.默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字
    2.public可以省略，default不能省略
    3.如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写

- 接口中的静态方法

  - 对于静态方法：如果是作为一个工具来使用的，就声明为static，不需要new一个对象就可以使用
  - 格式:public static 返回值类型 方法名(参数列表){ }
  - 范例:public static void show(){}
  - 注意事项:
    静态方法只能==通过接口名调用==，不能通过实现类名或者对象名调用
    public可以省略，static不能省略

- 接口代表规则，是行为的抽象。想要让哪个类拥有一个行为，就让这个类实现对应的接口就可以了。

- 当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态。

- 接口中的私有方法：普通私有，静态私有----抽象出的共有代码，不想被外界访问

- 适配器设计模式

  - 中间类（适配器类）,做空重写,让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。
  - 如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?

  > 可以在接口跟实现类中间，新建一个中间类（适配器类）
  > 让这个适配器类去实现接口，对接口里面的所有的方法做空重写。
  > 让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。
  > 因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象

### 10.内部类

- 将一个类A定义在另一个类B里面，里面的那个类A就称为**内部类**，B则称为**外部类**。可以把内部类理解成寄生，外部类理解成宿主。

- 一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用
- **成员内部类**，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)
- **静态内部类**，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)
- **局部内部类**，类定义在方法内
- **匿名内部类**，没有名字的内部类，可以在方法中，也可以在类中方法外。

- 成员内部类：

  - 外部类.内部类

  - ```java
    外部类.内部类 变量 = new 外部类（）.new 内部类（）;
    ```

  - outer.this.a  可以访问外部类成员变量
  - outer.this  获取外部类对象的地址值

  ![image-20241105192644502](https://gitee.com/ppedmo/pic-go/raw/master/img/202411051926563.png)

- 静态内部类：
  - 什么是静态内部类?
    静态内部类是一种特殊的成员内部类
  - 直接创建静态内部类对象的方式?
    Outer.Inner oi= new Outer.inner()
  - 如何调用静态内部类中的方法?
    非静态方法:先创建对象，用对象调用
    静态方法:外部类名.内部类名.方法名()

- 局部内部类
  1.将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量
  2.外界是无法直接使用，需要在方法内部创建对象并使用，
  3.该类可以直接访问外部类的成员，也可以访问方法内的局部变量。

- 匿名内部类

  - 隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置

  - ```java
    new 类名或者接口名(){
    重写方法
    };
    包含了继承或实现，方法重写，创建对象
    整体就是一个类的子类对象或者接口的实现类对象
    ```

  - 当方法的参数是接口或者类时
    以接口为例，可以传递这个接口的实现类对象
    如果实现类只要使用一次，就可以用匿名内部类简化代码