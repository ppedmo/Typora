# 实验二

进程PCB队列的组织、管理（以及进程调度）模拟实验。

（1）基本要求，事先构造一个 PCB 总链队列，可对该队列进行正常的 维护，即当PCB状态变化时，在总链队列的基础上，实现菜单式管理和进程原语 操作，实现创建、撤销、时间片到、挂起进程和激活进程等基本进程原语，以实 现PCB的就绪队列、等待队列的组织与管理；

- 结构体相关：

  - 定义PCB结构体

  - ```JAVA
    // 进程状态枚举
    enum ProcessStatus {
        READY,
        RUNNING,
        WAITING,
        ENDING
    };
    
    // 进程控制块 PCB 结构体
    struct PCB {
        int pid; // 进程 ID
        ProcessStatus status; // 进程状态
        int priority; // 进程优先级
        //还有指针域
        
    };
    ```

- PCB组织

  - 空闲队列

  - 总链

  - 就绪队列 等待队列

  - ```java
    // PCB 管理类
    class PCBManager {
    private:
        // 空闲 总链list 就绪队列 等待队列
        //空闲队列和总链加起来就是全部的PCB的空间
        //
    	//
    public:
        //创建、撤销、时间片到、挂起进程和激活进程等基本进程原语---函数
        //挂起进程：这个是要怎么样呢，原因就统一设为I/O
        //创建进程：分配一个新的PCB，并初始化其状态。就是从空闲队列上取，放到总链上
    	//撤销进程：清理PCB并释放相关资源，放回空闲队列上。
    	//时间片到：将当前运行的进程移回就绪队列，并从就绪队列中选择下一个进程运行（FIFO）。
    	//挂起进程：将进程从就绪队列移动到等待队列。 ???这是我有疑问的地方，就是怎么表示运行的状态，怎么触发挂起
    	//激活进程：将进程从等待队列移回就绪队列。
        //打印快照（当前运行的 就绪队列 等待队列 pid就可以了）
        //
    };
    
    ```

- 菜单式：

  - 

（2）扩展一，实现利用伙伴系统策 略对于资源池PCB队列和运行中的PCB队列的组织与管理；

//？？？           

（3）扩展二，考虑 利用进程调度程序来实现对CPU的控制与调度过程；

//可以使用简单的FIFO先进先出来模拟

（4）扩展三，实现PCB的 回收算法并考虑到PCB空白块的合并问题。

//？？？加一个空闲队列管理，暂时还没想好

# 算法--假币问题

8---332

9---333

10---334

11---443

12---444