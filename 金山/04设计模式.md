

# 一、设计模式

## 1.1设计模式简介

概念：设计模式提供了一种通用的方法来解决软件设计中的挑战，它们描述了如何组织类和对象以实现特定的目标。这些模式通过定义对象之间的关系和交互方式，帮助开发人员构建灵活、可扩展和易于维护的软件系统

## 1.2设计模式原则

设计原则，其实就是**程序员在编程**时，**应当遵守的原则**，也是各种设计模式的基础。

| 开闭原则     | 依赖倒转(倒置)原则 | 单一职责原则 | 接口隔离 |
| ------------ | ------------------ | ------------ | -------- |
| 里氏替换原则 | 迪米特法则         | 合成复用原则 |          |

**开闭原则：**

可读性可维护性好

可能在当前适用，但是几年后可能需要扩展

- 对扩展开放，对更改关闭
- 类模块应该是扩展的，但是不可修改

抽象类--实例一示例二

**单一职责原则：**

- 一个类（或模块、方法）应该只有一个引起它变化的原因，即 每个实体只负责一项独立的职责，并且该职责完全由该实体封装。
- 每个应该实现单一职责，否则就应该把类拆分，便于后期的维护

**依赖倒置原则：**

强调高层模块不应该依赖于低层模块的具体实现，而应该依赖于抽象

依赖倒置原则要求我们通过接口或抽象类来定义模块之间的通信，而不是依赖于具体的实现类

**里氏替换原则：**

- 该原则描述了子类型（派生类）在使用父类型（基类）对象的场景中的行为规范
- 子类型必须能够替换父类型，而不影响程序的正确性

**接口隔离原则：**

- 使用==多个专门的接口==，而不使用单一的总接口，不应该强迫客户程序依赖它们不用的方法
- 接口尽量细化，同时接口中的方法尽量少并且完备。

**迪米特原则：**

- 是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。
- 迪米特原则主要强调只与直接的朋友通信
  - **出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类**，
  - **出现在方法体内部的类不属于朋友类（以局部变量出现的耦合不属于直接朋友）**
- 关注于 对象之间的通信方式，要求对象只与其直接的朋友类进行交互

**合成复用原则：**

- 优先使用对象组合（has-a），而非继承（is-a） 来实现代码复用。
- 通过**将已有对象组合到新对象**中，可以更灵活地扩展功能，同时降低类之间的耦合度。

![image-20250511094227606](https://gitee.com/ppedmo/pic-go/raw/master/img/202505110942705.png)

## 1.3 设计模式类型

设计模式分为三种类型，共23种。

- 创建型模式：单例模式、工厂模式、抽象工厂模式、原型模式、建造者模式。

- 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。

- 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式(责任链模式)。

## 1.4 单例模式

- 一个类只有一个对象，并且只能通过接口创建对象

### 特点

- 单一实例
  - 单例模式确保一个类在整个系统生命周期内仅有一个实例存在
- 全局访问
  - 单例类会提供一个全局可访问的方法（通常为静态方法），让系统中的任何地方都能方便地获取该单例实例。

### 使用场景

- 当对象需要被共享的时候又或者某类需要频繁实例化.
  - **设备管理器**，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;
  - **数据池**，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;
  - **回收站**,在整个系统运行过程中，回收站一直维护着仅有的一个实例;
  - **应用程序的日志应用**，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加;
  - **网站的计数器**，一般也是采用单例模式实现，否则难以同步。

### 实现

饿汉式

懒汉式--多线程中会出现问题

c++推荐：

- 在 C++ 11 中，保证了==并发线程在获取静态局部变量时一定是初始化过的==，具有线程安全性
- 基于上述特性，来实现单例模式能够保证线程安全，实现比较简洁
- 行对于饿汉式，它的优势是只有调用getInstance()的内存才会创建，不会像饿汉式一样占用

```c++
#include <iostream>
#include <fstream>
#include <mutex>

class KLogger
{
public:
    static KLogger& getInstance()
    {
        static KLogger instance;
        return instance;
    }
    void log(const std::string& message)
    {
        std::lock_guard<std::mutex> lock(s_mtx);
        m_logFile << "[LOG] " << message << std::endl;
    }

private:
    KLogger()
    {
        m_logFile.open("app.log", std::ios::app);
    }
    ~KLogger()
    {
        if (m_logFile.is_open()) 
        {
            m_logFile << "[LOG] system shutdown" << std::endl;
            m_logFile.close();
        }
    }

    KLogger(const KLogger&) = delete;
    KLogger& operator = (const KLogger&) = delete;
    std::ofstream m_logFile;
    static std::mutex s_mtx;
};
std::mutex KLogger::s_mtx;

int main()
{
    KLogger::getInstance().log("Program Start");
    return 0;
}
```

![image-20250511101834769](https://gitee.com/ppedmo/pic-go/raw/master/img/202505111018824.png)

## 1.5工厂模式

- 工厂模式是一种创建对象的设计模式，它提供了一种将对象的创建和使用分离的方式。

- 针对某一类事物

### 简单工厂

- 通过引入一个简单工厂类来集中对象的创建过程，从而将客户端和具体对象的创建解耦

![image-20250511102055642](https://gitee.com/ppedmo/pic-go/raw/master/img/202505111020701.png)

创建逻辑--类型--具体产品

### 工厂方法（推荐使用）



### 抽象工厂

大型项目

产品一致性（一类风格一致的产品）

## 1.6命令模式