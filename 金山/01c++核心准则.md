# 一、前言

- 越是低级的代码效率越高，汇编> C > C++
  - 有误的，c++也是转到汇编的（由编译器写的），.exe都是汇编，效率主要看你汇编写得怎么样

- AI是工具

# 二、c++基础知识

## 构造/析构函数

对象创建与释放时自动调用的--和内存释放相关

c语言中要手动释放--可能因为分支或其他原因没法释放，即导致资源泄露

c++--==RAII==（资源获取即初始化）

## 一些准则

### 区分静态和运行时

- sizeof()在编译时就能确定的
- 依赖输入的大部分是运行时才能确定的
- dynamic_cast<Derived*>(b2)运行时的，效率低，尽量不要放在循环里

### 代码的直接表达

- 要让人看懂

- 函数名就要让人看懂

- 不要写注释

- ==注释是用来解释为什么的，不是解释为什么的==

- ```c++
  void fun(int a);//值传递
  void fun(int& a);//引用传递--可以修改值
  void fun(int* a);//指针传递
  void fun(const std:string& input)//需要引用（既不产生副本），但不能修改--故有一个const
  ```

- 取别名也是这样的 `using Speed = double;`

- 能遍历的：`for (const auto& student : student_table)`就遍历

### 不要泄露任何资源

后面会讲到--RAII

### 不要浪费时间或者空间

- 地址对齐--小的放在前面1大的放在后面（一般没啥问题）
- string--内部是小的
- 32位和64位程序区别：4个字节的指针（4g内存）和8个字节的指针
- 牛顿迭代法，精确到小数点后第8位

### 低耦合

- 反面案例--英雄联盟琴瑟仙女和水晶先锋

# 三、c++经典特性

## 面向对象

封装：抽象模型

继承+多态：

- 继承基类以获取其内容，来解决代码重用的问题。

- 声明某个子类完全兼容于某基类。

- 基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。

==虚函数==：（运行时的多态）

- c++的类中只有数据成员没有函数成员，是根据他的身份来的
- 要实现调用自己的函数--在基类中写一个虚函数（多态用的）
- 把函数存在数据里面--虚函数表
- 调用效率低，是其他函数的10到30倍
- 虚析构函数：当使用基类指针或引用指向派生类对象，并且需要通过基类指针来删除派生类对象时

C++中class和struct基本是等价的，一般来说当class中需要区分private成员的时候就定义为class。

## 面向过程

具体问题具体分析--拼音汉字拆解

## 泛型

是零成本的抽象

有成本的抽象：比用户传入int但是代码中出现了判断是int还是其他的这种代码，这就是有成本的

模板生成代码的代码

模板本身是不参与运作的

constexpr如果能被编译器计算出来，就会计算出来--但其实用处不大

## 函数式

写代码的时候尽量使用**纯函数**，不会受到外部因子影响，只与传入的参数相关

# 四、STL

## 容器

### array

静态数组`std::array<int, 10> a;`以后常规就这么表示，会帮助判断是否越界

在追求效率时用原始数组`int arr[10] = {0};`但是常常会出现错误

### ==vector==

动态数组，支持改变大小

改变大小的原理：有两个元素重要size capacity(容量)

- 当我们插入时，先判断容量是否够
- 如果够，直接插入
- 如果不够，开辟一个新空间，比原先大
- 再将原始数组中的数据复制过去，再把新数据加进去

首选是vector，插入操作多的也这样，他**在内存中是连续**的

### deque

多个数组关联起来的双端队列，主要用于在两端高效插入删除。可以理解为数组的链表

### list

双向链表，任务列表就是一个很经典的链表的例子

应用场景：需要很多内存的时候可以用list

### forward_list

单向链表，比如一个存储大量短信消息的消息队列

### set、multiset、map、multimap

底层是红黑树，自带排序的效果，进行一些平衡操作

avl树调整代价太高了--当插入要求不高但查找频繁可以用avl树

### unordered_set、unordered_multiset、unordered_map、unordered_multimap

底层数据结构都是哈希表

hash表扩容的时候相当于重新申请一个最外层数组，然后将元素一个一个重新计算hash函数添加进去，这个过程也会有一定的开销，在使用的时候最好能预设大小来**避免出现太多次的扩容**。

## 迭代器

用于遍历和访问容器中元素的对象

![image-20250316144401954](https://gitee.com/ppedmo/pic-go/raw/master/img/202503161444048.png)

**迭代器失效**是指在对容器进行一些修改操作后，原本有效的迭代器可能不再指向容器中的有效元素，或者指向的元素值发生了变化。这可能导致使用失效的迭代器进行访问或操作时出现未定义的行为

也就是当我push_back时可能导致扩容，迭代器指向的仍是原来的，迭代器是不会随vector扩容而更新的

- 用迭代器只用遍历，比如c开头的迭代器
- 添加或删除之后不用原来的迭代器，重新取一个迭代器

## 算法

**不要在代码中出现显式的for循环**，在写循环之前先思考自己所写的需求是不是一种已经实现的算法，stl有100多种算法，如果一个人的代码里有大量for循环，这意味着他不懂stl算法。

可以写完代码后用ai修改--请用stl优化算法

# 五、类型转化

可以这样`int num = {};`

## static_cast

编译期就已经完成的转化，要转的都可以用，能转的就没问题

（只有一种情况会出错，父类对象转化为子类对象，输出子类独有的属性）

```c++
	Com* c = new Com;
	Cola* cola = static_cast<Cola*>(c);
	std::cout<< cola->v;
```



## reinterpret_cast

比较危险的转换
常用的场景一般是指针转整数或者是整数转指针等场景

## dynamic_cast

建议别使用

## const_cast

const_cast用来去掉const类型的const限制，常用的场景是如果一个函数的参数需要一个非const类型，然而你手头只有一个const类型。当然，也可以去掉类型的volatile 和 __unaligned属性。

不要用const_cast去修改const类型的对象值，这属于**未定义行为**

只能去掉const属性不能改值

一般再传参中使用

# 六、工具篇

## 编译器调试入门

断点，内存，堆栈，模块，反汇编

## git使用

**版本控制**

**远程仓库**

github就是一个远程仓库，对应的就是存储文件的远程物理机器，表现在本地就是一个远程路径（url）

**版本库**

一个被隐藏的.git文件夹

**工作区**

就是当前的目录下的文件，add之后才会关注

**暂存区**

index文件，执行git add之后工作区相关文件会加入暂存区

执行==git commit==之后暂存区的文件会被加入版本库

**git提交作业的基本流程：**

1. 创建本地git仓库，然后开始编写代码，代码的改动最好是每一个完整改动都用一次commit提交，最好不要一个commit提交大量改动
2. 将本地仓库和远程仓库关联
3. 将本地仓库中的代码push到远程仓库，并且测试从远程仓库pull代码到本地

# 七、多线程

## 多线程入门

2011年以后多核CPU才商业化，大家能用，所以2011年之后才加入c++库中

多线程用来干什么的：使用多线程的主要目的是提高程序的并发性和性能，尤其是在需要同时处理多个任务时，能够更高效地利用多核 CPU 资源。

以前只有一个cpu时，为了处理有UI的程序有了多线程的概念

通常一个核心能跑两个线程，只是intel的标准，现在不一样了。

与硬件相关

在做优化时：测出来，如果可以的话调研一下用户使用最多机型，用相同环境去测试

线程函数有参数的时候，将参数依次写在后面即可：

```c++
void print(int x) { 
    std::cout << x;
}

int main() {
    int value = 42;
    thread t(print,value);
    t.join();
    return 0;
}
```

因为 `std::thread` 默认会拷贝参数，使用 `std::ref` 强制传递引用，确保修改原变量而非其副本。若不用 `std::ref`，函数实际接收的是拷贝值，导致无法正确修改 `value`，结果仍为 42。

## 数据共享

最后一张票，两个人同时来买票，应该卖给谁：对于CPU来说**同时**意味着在同一个震荡区间内；买到了同一张票；ticket存于CPU的cache中，不是内存中的；需要有一个强有力的保护--锁即互斥量



## 互斥量

如果有人已经lock，那么其他线程会被阻塞--即完成了同一时间只有一个线程在执行

std::mutex

![image-20250323100518843](https://gitee.com/ppedmo/pic-go/raw/master/img/202503231005974.png)



**阻塞**--暂时陷入自旋，此时它会独占一个线程通道，自选期间如果lock的线程执行了unlock它就可以继续执行下去。但是如果lock的线程迟迟执行不到unlock，那么操作系统是不会允许这个线程通道一直被这个自旋的线程独占，这时候会从***\*用户态\****转入***\*内核态\****，让出线程通道来让别的线程执行。（先自选再挂起，内核态效率大幅下降）

减少转入内核态的情况：

- 不要启动太多线程
- 不要去锁乱七八糟的东西，锁关键的

这里够简单，可以不用锁，使用原子变量std::atomic与操作系统无关，不会进入内核态

## 粒度

程序在哪些关键步骤需要加锁被称之为锁的粒度

### lock_guard

`std::lock_guard<std::mutex> guard(ticket);` 

用于自动管理互斥锁（`mutex`）的加锁和解锁

粒度较大

可以用大括号控制它的生命周期

### thread_local

每个线程都有其独立的变量副本，线程之间不会共享这些变量。

thread_local int ticket = 100;==>每个线程有自己的副本，开销大

### unique_lock

`std::unique_lock<std::mutex> guard(ticket);` 

和lock_guard一样，但是可是手动unlock

## 死锁

一种是我们不对可能出现冲突的局部加锁，而是对整个任务加锁。（两把锁变一把锁）--任务类型是固定的（先算后存，先存后算）/成本（超时代价太大）

另一种解法是当一个任务持有锁超时之后就释放任务，短暂等待后重新执行任务。--（先算后存，先存后算，存，算）/大部分时间不会冲突

## 条件变量

解决通知问题

std::condition_variable cv;

cv.wait();

cv.notify_all();

## 线程池

创建一个线程的成本很高，预制很多个线程

--池化



# 八、RAII

==RAII的核心思想==是将资源的生命周期与对象的生命周期绑定在一起，通过对象的构造函数和析构函数来管理资源。

只要出现new delete...都可能发生泄露。

string长度在15一下是不用new的

指针都是new出来的--所以使用RAII就是为了消灭指针

## 智能指针

程序结束了泄露的就释放了

尽量避免

### 资源与所有权（Ownership）

所有权决定了 **资源何时分配、何时释放，以及哪个对象有权操作资源**。

我们仅有在涉及到**传递所有权的时候才使用智能指针**。这意味着智能指针应该用于**管理资源的生命周期**，而不应仅仅作为普通指针的替代品。

### `std::unique_ptr`（唯一所有权）

```c++
//a唯一所有
int* a = new int(5);

//ab共同享有--常出现在函数传参中
int* a = new int(5);
int* b = a;

//
std::unique_ptr<int> a = int(5);
auto int_ptr = std::make_unique<int>(42);  // 管理单个 int 对象
auto arr_ptr = std::make_unique<int[]>(5); // 管理 int 数组
```



### `std::shared_ptr`（共享所有权）

是有成本的

共享只是访问权，析构资源是共同管理的

最后一个用完的释放资源--通过引用计数管理生命周期

```c++
auto s_ptr1 = std::make_shared<int>(5);
auto s_ptr2 = s_ptr1;
auto ptr2 = std::move(ptr);           // 所有权转移
```

会导致资源得不到释放--占内存、

###  `std::weak_ptr`（非所有权）

优化s_ptr⬆⬆⬆

## lambda表达式

定义：一种在调用**匿名**函数对象或作为函数的参数传递的位置定义匿名函数对象的便捷方法。--只在某处调用了一次

另外一种定义：构造一个闭包：一个能够捕获作用域中变量的未命名函数对象（闭包的意思是将函数与环境一起存储的记录。）

`[](){};`

[]中括号用于捕获参数

```c++
sort(vec.begin(), vec.end(), [](const int& a, const int& b) {return a > b; });
[&a](){
    
}
//也可以有名字
auto fun = [](){
    
};
fun();
fun();
std::sort(stu.begin(),stu.end() , [](const Student &a, const Student & b) {
        return a.num < b.num;
        });
```

# 九、右值引用

对效率提升很有用

复制：两份

**移动**：move-->把str1中的内容给str2，str1中没东西了，更高效

&&：右值引用--是为了找移动构造函数

=进行的操作，右边是&&类型

# 十、新语法和其他

## auto

什么情况不使用auto？

```c++
int main() {
    std::vector<bool> vec{0,1,1,1,0};
    bool var = vec[3];
    auto var2 = vec[3];//去除的是一个bit位
    return 0;
}
```

在c++中不直接操作比特，操作字节，

## decltype

核心：推导类型

## nullptr

nullptr的类型为std::nullptr_t//比较好

而NULL的类型为int//任何情况下都不用

## 新关键词

### override(重要且常见)

用于明确指示派生类中的成员函数是对基类中的虚函数的重写。

### explicit(重要且常见)

发生了隐式类型转换的有风险代码（如果构造函数只有一个参数的话）

### delete

可以通过 delete 来删除或禁用特殊成员函数，例如禁止复制构造函数或移动赋值运算符的使用。

`bool isLucky(char) = delete; `

### default

用于生成默认的特殊成员函数实现。

##### final

用于标记虚函数，表示该函数不能在派生类中再次被重写。

##### constexpr

常量函数计算

### std::tuple

元组：`std::tuple<int, std::string, double> myTuple(42, "Hello", 3.14159);`