# 一、前言

- 越是低级的代码效率越高，汇编> C > C++
  - 有误的，c++也是转到汇编的（由编译器写的），.exe都是汇编，效率主要看你汇编写得怎么样

- AI是工具

# 二、c++基础知识

## 构造/析构函数

对象创建与释放时自动调用的--和内存释放相关

c语言中要手动释放--可能因为分支或其他原因没法释放，即导致资源泄露

c++--==RAII==（资源获取即初始化）

## 一些准则

### 区分静态和运行时

- sizeof()在编译时就能确定的
- 依赖输入的大部分是运行时才能确定的
- dynamic_cast<Derived*>(b2)运行时的，效率低，尽量不要放在循环里

### 代码的直接表达

- 要让人看懂

- 函数名就要让人看懂

- 不要写注释

- ==注释是用来解释为什么的，不是解释为什么的==

- ```c++
  void fun(int a);//值传递
  void fun(int& a);//引用传递--可以修改值
  void fun(int* a);//指针传递
  void fun(const std:string& input)//需要引用（既不产生副本），但不能修改--故有一个const
  ```

- 取别名也是这样的 `using Speed = double;`

- 能遍历的：`for (const auto& student : student_table)`就遍历

### 不要泄露任何资源

后面会讲到--RAII

### 不要浪费时间或者空间

- 地址对齐--小的放在前面1大的放在后面（一般没啥问题）
- string--内部是小的
- 32位和64位程序区别：4个字节的指针（4g内存）和8个字节的指针
- 牛顿迭代法，精确到小数点后第8位

### 低耦合

- 反面案例--英雄联盟琴瑟仙女和水晶先锋

# 三、c++经典特性

## 面向对象

封装：抽象模型

继承+多态：

- 继承基类以获取其内容，来解决代码重用的问题。

- 声明某个子类完全兼容于某基类。

- 基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。

==虚函数==：（运行时的多态）

- c++的类中只有数据成员没有函数成员，是根据他的身份来的
- 要实现调用自己的函数--在基类中写一个虚函数（多态用的）
- 把函数存在数据里面--虚函数表
- 调用效率低，是其他函数的10到30倍
- 虚析构函数：当使用基类指针或引用指向派生类对象，并且需要通过基类指针来删除派生类对象时

C++中class和struct基本是等价的，一般来说当class中需要区分private成员的时候就定义为class。

## 面向过程

具体问题具体分析--拼音汉字拆解

## 泛型

是零成本的抽象

有成本的抽象：比用户传入int但是代码中出现了判断是int还是其他的这种代码，这就是有成本的

模板生成代码的代码

模板本身是不参与运作的

constexpr如果能被编译器计算出来，就会计算出来--但其实用处不大

## 函数式

写代码的时候尽量使用**纯函数**，不会受到外部因子影响，只与传入的参数相关

# 四、STL

## 容器

### array

静态数组`std::array<int, 10> a;`以后常规就这么表示，会帮助判断是否越界

在追求效率时用原始数组`int arr[10] = {0};`但是常常会出现错误

### ==vector==

动态数组，支持改变大小

改变大小的原理：有两个元素重要size capacity(容量)

- 当我们插入时，先判断容量是否够
- 如果够，直接插入
- 如果不够，开辟一个新空间，比原先大
- 再将原始数组中的数据复制过去，再把新数据加进去

首选是vector，插入操作多的也这样，他**在内存中是连续**的

### deque

多个数组关联起来的双端队列，主要用于在两端高效插入删除。可以理解为数组的链表

### list

双向链表，任务列表就是一个很经典的链表的例子

应用场景：需要很多内存的时候可以用list

### forward_list

单向链表，比如一个存储大量短信消息的消息队列

### set、multiset、map、multimap

底层是红黑树，自带排序的效果，进行一些平衡操作

avl树调整代价太高了--当插入要求不高但查找频繁可以用avl树

### unordered_set、unordered_multiset、unordered_map、unordered_multimap

底层数据结构都是哈希表

hash表扩容的时候相当于重新申请一个最外层数组，然后将元素一个一个重新计算hash函数添加进去，这个过程也会有一定的开销，在使用的时候最好能预设大小来**避免出现太多次的扩容**。

## 迭代器

用于遍历和访问容器中元素的对象

![image-20250316144401954](https://gitee.com/ppedmo/pic-go/raw/master/img/202503161444048.png)

**迭代器失效**是指在对容器进行一些修改操作后，原本有效的迭代器可能不再指向容器中的有效元素，或者指向的元素值发生了变化。这可能导致使用失效的迭代器进行访问或操作时出现未定义的行为

也就是当我push_back时可能导致扩容，迭代器指向的仍是原来的，迭代器是不会随vector扩容而更新的

- 用迭代器只用遍历，比如c开头的迭代器
- 添加或删除之后不用原来的迭代器，重新取一个迭代器

## 算法

**不要在代码中出现显式的for循环**，在写循环之前先思考自己所写的需求是不是一种已经实现的算法，stl有100多种算法，如果一个人的代码里有大量for循环，这意味着他不懂stl算法。

可以写完代码后用ai修改--请用stl优化算法

# 类型转化

可以这样`int num = {};`

## static_cast

编译期就已经完成的转化，要转的都可以用，能转的就没问题

（只有一种情况会出错，父类对象转化为子类对象，输出子类独有的属性）

```c++
	Com* c = new Com;
	Cola* cola = static_cast<Cola*>(c);
	std::cout<< cola->v;
```



## reinterpret_cast

比较危险的转换
常用的场景一般是指针转整数或者是整数转指针等场景

## dynamic_cast

建议别使用

## const_cast

const_cast用来去掉const类型的const限制，常用的场景是如果一个函数的参数需要一个非const类型，然而你手头只有一个const类型。当然，也可以去掉类型的volatile 和 __unaligned属性。

不要用const_cast去修改const类型的对象值，这属于**未定义行为**

只能去掉const属性不能改值

一般再传参中使用

# 六、工具篇

## 编译器调试入门

断点，内存，堆栈，模块，反汇编

## git使用

**版本控制**

**远程仓库**

github就是一个远程仓库，对应的就是存储文件的远程物理机器，表现在本地就是一个远程路径（url）

**版本库**

一个被隐藏的.git文件夹

**工作区**

就是当前的目录下的文件，add之后才会关注

**暂存区**

index文件，执行git add之后工作区相关文件会加入暂存区

执行==git commit==之后暂存区的文件会被加入版本库

**git提交作业的基本流程：**

1. 创建本地git仓库，然后开始编写代码，代码的改动最好是每一个完整改动都用一次commit提交，最好不要一个commit提交大量改动
2. 将本地仓库和远程仓库关联
3. 将本地仓库中的代码push到远程仓库，并且测试从远程仓库pull代码到本地



**作业写一个vector**提交到第一次仓库中

考试链接，不计分